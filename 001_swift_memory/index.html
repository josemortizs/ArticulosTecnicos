<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swift, conoce su memoria y optimiza tus abstracciones</title>
    <style>
        body {
            margin: 0 auto;
            max-width: 1024px;
            padding: 20px;
        }
        header, footer {
            text-align: center;
        }
        article {
            margin-top: 20px;
        }
        section {
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            padding: 10px;
            border: 1px solid #ccc;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        aside {
            background-color: #f2f2f2; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
            margin-bottom: 20px; 
        }
        aside p {
            margin: 0;
        }
        pre {
            background-color: #1e1e1e;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body>
    <header>
        <h1>Gestión de la memoria en Swift</h1>
        <p>Una explicación sobre la gestión de la memoria y cómo aprovechar las estructuras para optimizar tus abstracciones</p>
    </header>
    <article>
        <section>
            <h2>Introducción</h2>
            <p>
                En Swift, como en muchos otros lenguajes de programación, la gestión de la memoria es una parte esencial para 
                garantizar un rendimiento óptimo y prevenir problemas como fugas de memoria o accesos inválidos a la memoria. 
                En Swift, la gestión de la memoria se lleva a cabo principalmente en dos áreas: la pila (<b>Stack</b>) y el montón (<b>Heap</b>).
                Paciencia aquí, acabarás familiarizado con estos dos términos pronto...
                <br><br>
                Listemos algunas diferencias entre <b>Heap</b> y <b>Stack</b>, montón y pila. No os molestéis en intentar memorizar nada, esta 
                tabla solo busca ser una referencia, un sitio al que podamos volver si tenemos dudas sobre una determinada
                característica de nuestras dos nuevas mejores amigas. 
            </p>
        </section>
        <section>
            <h2><b>Stack</b> y <b>Heap</b>, cara a cara</h2>
            <table>
                <thead>
                    <tr>
                        <th>Característica</th>
                        <th><b>Stack</b></th>
                        <th><b>Heap</b></th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Asignación de memoria:</td>
                        <td>Estática, se realiza durante la compilación</td>
                        <td>Dinámica, tiene lugar en tiempo de ejecución</td>
                    </tr>
                    <tr>
                        <td>Acceso:</td>
                        <td>Rápido, debido a la asignación y liberación automática de memoria</td>
                        <td>Un poco más lento, implica más gestión de la memoria mediante contadores de referencias o ARC</td>
                    </tr>
                    <tr>
                        <td>Usada para almacenar:</td>
                        <td>Tipos de datos por valor: estructuras, enumerados... *</td>
                        <td>Tipos de datos por referencia: clases, actores... *</td>
                    </tr>
                    <tr>
                        <td>Seguridad:</td>
                        <td>
                            Cada hilo tiene su propia <b>Stack</b> de memoria, por lo que no pueden producirse accesos simultáneos
                            a datos "de estado compartido" que puedan producir las famosas "conditions race". **
                        </td>
                        <td>
                            Todos los hilos acceden al mismo <b>Heap</b> por lo que pueden producirse "conditions race", así que los
                            datos deben de estar protegidos ante esta casuística. **
                        </td>
                    </tr>
                    <tr>
                        <td>Rendimiento:</td>
                        <td>
                            Rendimiento muy alto. ***
                        </td>
                        <td>
                            Menor rendimiento debido a diversos factores. ***
                        </td>
                    </tr>
                </tbody>
            </table>
            <aside>
                <p>
                    <b>(*)</b> ¿Quiere decir esto que siempre que cree un tipo de dato mediante <b>Struct</b> sus objetos van a 
                    ser almacenados en el <b>Stack</b>?, no, desgraciadamente no es tan sencillo. 
                    <br><br>
                </p>
                <p>
                    <b>(**)</b> Cada hilo de ejecución tiene su propio <b>Stack</b> de memoria mientras que el <b>Heap</b> es compartido por 
                    todos los hilos. Como varios hilos de ejecución pueden asignar memoria en el <b>Heap</b> al mismo tiempo éste debe 
                    protegerse mediante bloqueos, semáforos u otros mecanismos de sincronización. Esto supone un coste bastante
                    grande de rendimiento.
                    <br><br>
                </p>
                <p>
                    <b>(***)</b> La gestión de la memoria que hace Swift mediante el <b>Stack</b>, de forma estática, es muy eficiente. 
                    La pila funciona mediante un sistema de LIFO, imagen 1. Swift puede agregar la información que necesite a la 
                    pila, "Allocation", de forma muy rápida y limpiarla de ésta igual de rápido, "Deallocation".
                    <br><br>
                    En la Imagen 2 podemos observar otra representación gráfica de cómo Swift agregaría datos al Stack y cómo los liberaría,
                    cuando ya no fuesen necesarios, mediante dicho sistema LIFO (Last in, First Out).
                    <br><br>
                    Mientras tanto, la asignación dinámica en el <b>Heap</b> (montón), implica que debamos encontrar un espacio en memoria 
                    con el tamaño apropiado y, cuando ya no la necesitemos, desasignarla adecuadamente, incurriendo en una gestión 
                    mucho más compleja, y por ende menos eficiente, que la usada para almacenar en la <b>Stack</b> (pila).
                </p>
                <br>
                <div style="display: flex; justify-content: space-between;">
                    <img src="images/stack_01.png" alt="Imagen 1" style="max-width: calc(50% - 10px); border-radius: 5px;">
                    <img src="images/stack_02.png" alt="Imagen 2" style="max-width: calc(50% - 10px); border-radius: 5px;">
                </div>
                <br>
                <div style="display: flex; justify-content: space-between;">
                    <span style="max-width: calc(50% - 10px); border-radius: 5px;">Imagen 1</span>
                    <span style="max-width: calc(50% - 10px); border-radius: 5px;">Imagen 2</span>
                </div>
            </aside>
            <p>
                Si queremos que nuestras abstracciones sean rápidas, y óptimas, necesitamos tener en cuenta todas y cada una de 
                las cuestiones que acabamos de leer, más algunas otras como el despachado dinámico y estático de métodos que veremos 
                en el siguiente artículo.
            </p>
        </section>
        <section>
            <h2>¿Hay código o no hay código?...</h2>
            <p>
                Vamos a verlo con código, usando los mismos ejemplos que puso Apple en la WWDC 2016, conferencia "Understanding Swift Performance".
            </p>
            <div style="display: flex;">
                <pre style="flex: 3; margin-right: 10px;">
                    <code>
    struct Point {
        var x, y: Double
    }

    let point1 = Point(x: 0, y: 1)
    var point2 = point1
    point2.x = 5
                    </code>
                </pre>
                <img src="images/stack_03.png" alt="Representación gráfica de cómo quedaría el stack tras el código" style="flex: 1; max-width: calc(35% - 10px); max-height: 100%; border-radius: 5px;">
            </div>
            <p>
                Este sencillo ejemplo no haría uso del Heap, ambas estructuras serían almacenadas en la Stack de memoria correspondiente. Hemos agregado una
                representación de cómo quedaría dicho Stack. Para ello, y por tratarse solo de una representación, sin más ambición que el de aportar
                una ayuda visual a la explicación, hemos usado la típica hoja de cálculo a la que todos estamos acostumbrados. ¿Cómo sería su comportamiento
                en memoria si usásemos una clase?, veámoslo con un ejemplo: 
            </p>
        </p>
        <div style="display: flex;">
            <pre style="flex: 3; margin-right: 10px;">
                <code>
    class Point {
        var x, y: Double
        init(x: Double, y: Double) {
            self.x = x
            self.y = y
        }
    }
    
    let point1 = Point(x: 0, y: 0)
    let point2 = point1
    point2.x = 5
                </code>
            </pre>
            <img src="images/stack_and_heap_01.png" alt="Representación gráfica de cómo quedaría el stack, y el heap, tras el código" style="flex: 1; max-width: calc(45% - 10px); max-height: 100%; border-radius: 5px;">
        </div>
        <p>
            Cómo podemos apreciar en la representación de memoria, para este ejemplo, Swift tiene que hacer uso del Heap para almacenar los datos del 
            objeto creado, con todos los costes de rendimiento, seguridad, etc, que hemos visto en el bloque anterior. Además podemos observar 
            que Swift sigue teniendo que hacer uso de la Stack correspondiente para almacenar las referencias a <b>101C1D580</b>, tanto para el objeto point1
            como para el objeto point2. 
        </p>
        <p>
            <b>101C1D580</b> es un referencia de memoria de ejemplo, para simular una real donde se almacenarían los datos. 
            Muchos, al llegar hasta aquí, os preguntaréis por qué hay cuatro "espacios" de memoria cuando para "almacenar" la estructura solo hacían falta dos. 
            Veamos, uno de los espacios, al que llamaremos <b>refCount</b>, es usado por ARC para almacenar el número de "referencias activas" que apuntan a dicha posición 
            de memoria y el otro se usa para almacenar el tipo de objeto. Cuando hablemos del despachado dinámico y estático de métodos de clase este "espacio" cobrará su
            debida importancia, por ahora, obviémoslo, Swift lo necesita y lo reserva en consecuencia. 
        </p>
        <p>
            Por cierto, cuando este <b>refCount</b> llega a 0 implica que ya no está siendo "apuntado" por ningún objeto, con lo que Swift procede a reciclarlo de la memoria.
            ¿Alguna vez os han preguntado en una entrevista por los "retain cycles"?, ¿"circular references"?, no lo veremos hoy, pero como suele decirse: por aquí van los 
            tiros...
        </p>
        </section>
        <section>
            <h2>Structs ineficientes y alternativas a éstos</h2>
            <p>
                Revisemos la siguiente implementación para aprender, con un ejemplo de Apple, de algunas trampas en las que podemos caer al implementar nuestras
                funcionalidades, abstracciones, etc:
            </p>
            <pre style="flex: 3; margin-right: 10px;">
                <code>
    enum Color { case blue, green, gray }
    enum Orientation { case left, right }
    enum Tail { case none, tail, buble }

    var cache [String: UIImage]()

    func makeBalloon(_ color: Color, orientation: Orientation, tail: Tail) -> UIImage {
        let key = "\(color):\(orientation):\(tail)"
        if let image = cache[key] { return image }
        // Aquí iría el resto de implementación para devolver el UIImage correspondiente,
        // no nos vale para el ejemplo así que la obvio.
    }
                </code>
            </pre>
            <p>
                La función se ocupa de crear los típicos "globitos" que se usan en viñetas, comics, etc, para mostrar una conversación 
                con un lazo-flecha apuntando hacia la persona que está hablando. Como tanto el color, como la orientación y el tipo de lazo son finitos
                y pueden parametrizarse, contabilizarse, etc, nuestro desarrollador ha usado enums para establecer estos parámetros de forma muy acertada.
                También ha creado un array para almacenar diccionarios y en base a una key de tipo String poder devolver su UIImage correspondiente si 
                esta ya ha sido procesada y así no tener que volver a procesar un "globito" si ya ha sido procesado anteriormente. 
            </p>
            <p>
                Por desgracia no ha tenido en cuenta que dichos Strings harán uso del Heap e incurrirán en conteo de referencias, necesidad de protección
                de la información, acceso más lento, etc. <br>
                Y aquí es dónde podríamos estar pensando: "¿Pero el String en Swift no se implementa mediante una estructura?, ¿Las estructuras no tenían
                paso por valor?, ¿no nos has contado que las estructuras usan el Stack?"
            </p>
            <p>
                En realidad no, ya que esto depende de la implementación interna de String, al igual que, como veremos
                más adelante en este mismo artículo, la implementación de nuestros tipos de datos serán los que determinen
                si acaban usando la Stack o el Heap. 
            </p>
            <p>
                ¿Cómo podríamos optimizar nuestro código?, Apple nos da la siguiente 
                alternativa: 
            </p>
            <pre style="flex: 3; margin-right: 10px;">
                <code>
    enum Color { case blue, green, gray }
    enum Orientation { case left, right }
    enum Tail { case none, tail, buble }

    struct Attributes: Hashable {
        var color: Color
        var orientation: Orientation
        var tail: Tail
    }

    var cache = [Attributes: UIImage]()

    func makeBalloon(_ color: Color, orientation: Orientation, tail: Tail) -> UIImage {
        let key = Attributes(color: color, orientation: orientation, tail: tail)
        if let image = cache[key] { return image }
        // Aquí iría el resto de implementación para devolver el UIImage correspondiente,
        // no nos vale para el ejemplo así que la obvio.
        return UIImage()
    }
                </code>
            </pre>
            <p>
                Podemos crear una estructura en la que "almacenar" los valores que necesitamos para la creación de 
                nuestro "balloon". Necesitamos que implemente el protocolo Hashable para que pueda hacer de clave 
                en el diccionario. Con esto, además, evitaríamos usar claves que bien podrían no tener nada que ver
                con el contenido a almacenar. Pero, ¿realmente es notable el cambio?, usemos a nuestro buen amigo 
                XCTest para realizar un par de pruebas de rendimiento: 
            </p>
            <pre style="flex: 3; margin-right: 10px;">
                <code>
    import XCTest

    enum Color { case blue, green, gray }
    enum Orientation { case left, right }
    enum Tail { case none, tail, buble }

    struct Attributes: Hashable {
        var color: Color
        var orientation: Orientation
        var tail: Tail
    }

    final class MemoryHeapAndStacksTests: XCTestCase {
        
        func testWithString() throws {
            self.measure {
                for _ in 1...1_000_000 {
                    _ = "\(Color.blue):\(Orientation.left):\(Tail.buble)"
                }
            }
        }
        
        func testWithStruct() throws {
            self.measure {
                for _ in 1...1_000_000 {
                    _ = Attributes(color: .blue, orientation: .left, tail: .buble)
                }
            }
        }
    }
                </code>
            </pre>
            <p>
                El primer test, testWithString, tardó 1.9 segundos de media en ejecutarse (se ejecuta 10 veces y nos 
                muestra la media de todas las ejecuciones) mientras que el segundo, testWithStruct, solo 0.17 segundos.
                No parece poca la diferencia...
            </p>
            <div style="display: flex; justify-content: space-between;">
                <img src="images/average_03.png" alt="Muestra el tiempo que tarda en 
                 el primer test: 1.9 segundos" style="max-width: calc(50% - 10px); border-radius: 5px;">
                <img src="images/average_04.png" alt="Muestra el tiempo que tarda en 
                el segundo test: 0.17 segundos" style="max-width: calc(50% - 10px); border-radius: 5px;">
            </div>
        </section>
    </article>
    <footer>
        <p>&copy; 2024 José Manuel Ortiz Sánchez - Senior iOS Development at <b>SNGULAR</b></p>
    </footer>
</body>
</html>